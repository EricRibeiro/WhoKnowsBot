import random
import time
from datetime import datetime, timedelta
from time import strptime

from requests import ConnectionError
from twitter import error  # Errors generated by Twitter API

from configuration import twitter_connection
from utils import file_utility
from utils import text_utility
from utils import time_utility
from whoknowsbot.mentions_replies import MentionsReplies


class TwitterBot(object):
    def __init__(self):
        self.api = twitter_connection.open_connection()
        self.replies = MentionsReplies(self.api)

    def test(self):
        pass

    def listener(self):
        while True:
            try:
                time_before_processing = datetime.now()

                search_limit = file_utility.read('resources/search_limit.txt')
                new_mentions = self.get_bot_mentions(search_limit)

                for mention in new_mentions:
                    tweet_text = mention.text
                    tweet_text_splitted = tweet_text.split(" ")

                    if len(mention.hashtags) > 0:
                        if tweet_text_splitted[1].upper() == "QUANTOSSABEM":
                            self.how_many_knows(mention)
                        elif tweet_text_splitted[1].upper() == "QUEMSABE":
                            self.who_knows(mention)
                        else:
                            pass
                    else:
                        pass

                time_after_processing = datetime.now()
                processing_duration = (time_after_processing - time_before_processing).total_seconds()
                {} if processing_duration > 60 else time.sleep(60 - processing_duration)

            # If something happens with the network, sleep for 1 minute and restart bot.
            except ConnectionError as e:
                message = str(datetime.now()) + " - " + "Listener" + ": " + e.args[0].args[0] + "\n"
                file_utility.append('resources/errors_log.txt', message)

                time.sleep(60)

    def who_knows(self, mention):
        term = mention.hashtags[0].text
        user_name = mention.user.screen_name
        user_id = mention.user.id

        print("Analisando menção de: " + str(user_name) + " | QUEMSABE")

        followers = self.get_user_base(user_id, "followers")
        followers_used_term = self.get_users_posts_term(followers, term)
        lowest_timestamp = self.get_lowest_timestamp(followers_used_term)

        if lowest_timestamp == 9999999999999:
            self.replies.reply_mention_who_know(mention.id, term, mention.user.screen_name, None)
        else:
            current_timestamp = time_utility.get_current_timestamp()
            suitable_follower_score = 0
            suitable_follower_id = None

            for follower in followers_used_term:
                score = 0
                for tweet in followers_used_term[follower]:
                    if tweet.retweeted_status is not None:
                        score = score + 0.5
                    elif tweet.in_reply_to_user_id is not None:
                        score = score + 1.0
                    else:
                        score = score + 0.75

                    tweet_timestamp = time_utility.convert_to_timestamp(tweet.created_at)
                    score = score + (1 - (current_timestamp - tweet_timestamp) / (current_timestamp - lowest_timestamp))

                if score > suitable_follower_score:
                    suitable_follower_score = score
                    suitable_follower_id = follower

            suitable_follower_screen_name = self.get_user_name(suitable_follower_id)
            self.replies.reply_mention_who_know(mention.id, term, mention.user.screen_name,
                                                suitable_follower_screen_name)

    def how_many_knows(self, mention):
        term = mention.hashtags[0].text
        user_name = mention.user.screen_name
        user_id = mention.user.id

        print("Analisando menção de: " + str(user_name) + " | QUANTOSSABEM")

        friends_with_knowledge = 0
        total_of_specialization = 0

        friends = self.get_user_base(user_id, "friends")
        friends_used_term = self.get_users_posts_term(friends, term)

        for friend in friends_used_term:
            friend_actions_with_term = len(friends_used_term[friend])

            if friend_actions_with_term > 0:
                max_id = 9000000000000000000
                tweets = []

                try:
                    tweets = self.api.GetUserTimeline(count=200, user_id=friend, max_id=max_id,
                                                      exclude_replies=False, include_rts=True)
                except error.TwitterError as e:
                    message = str(datetime.now()) + " - " + "GetUserTimeline" + ": " + e.message[1] + "\n"
                    file_utility.append('resources/errors_log.txt', message)

                friends_with_knowledge += 1
                total_of_specialization += friend_actions_with_term / len(tweets)

        proportion_of_knowledge = friends_with_knowledge / len(friends)
        level_of_specialization = total_of_specialization / len(friends)

        self.replies.reply_mention_how_many(mention.id, term, mention.user.screen_name, friends_with_knowledge,
                                            proportion_of_knowledge, level_of_specialization)

    def get_lowest_timestamp(self, users_used_term):
        lowest = 9999999999999

        for user in users_used_term:
            for tweet in users_used_term[user]:
                timestamp = time_utility.convert_to_timestamp(tweet.created_at)

                if timestamp < lowest:
                    lowest = timestamp

        # Return the lesser timestamp among all post analysed
        return lowest

    def get_users_posts_term(self, user_base, term):
        dic_users_used_term = {}

        # Get the date from 7 days ago
        limit_date = datetime.strptime(str(datetime.now()),
                                       '%Y-%m-%d %H:%M:%S.%f') - timedelta(days=7)

        for user in user_base:
            tweets = []
            max_id = 9000000000000000000
            current_time_line = []

            while True:
                time.sleep(1)
                try:
                    current_time_line = self.api.GetUserTimeline(count=200, user_id=user, max_id=max_id,
                                                                 exclude_replies=False, include_rts=True)
                except error.TwitterError as e:
                    message = str(datetime.now()) + " - " + "GetUserTimeline" + ": " + e.message[1] + "\n"
                    file_utility.append('resources/errors_log.txt', message)

                # For each post collected...
                for tweet in current_time_line:

                    # If term exists into a tweet....
                    if text_utility.accent_remover(tweet.text).count(text_utility.accent_remover(term)) > 0:

                        # Get when the tweet was created in format yyyy-mm-dd HH-MM-SS
                        created = tweet.created_at.split(" ")
                        tweet_date = created[5] + "-" + str(strptime(created[1], '%b').tm_mon) + "-" + created[2] + \
                                     " " + created[3]
                        tweet_date = datetime.strptime(tweet_date, '%Y-%m-%d %H:%M:%S')

                        # If post is recenter than limitDate...
                        if tweet_date > limit_date:
                            tweets.append(tweet)
                        else:
                            break

                # Stop the reading if the user time line finish
                if len(current_time_line) == 0:
                    break
                else:
                    # Get when a post was created in format YYYY-mm-dd HH-MM-SS
                    created = current_time_line[len(current_time_line) - 1].created_at.split(" ")
                    tweet_date = created[5] + "-" + str(strptime(created[1], '%b').tm_mon) + "-" + created[2] + \
                                 " " + created[3]
                    tweet_date = datetime.strptime(tweet_date, '%Y-%m-%d %H:%M:%S')

                    # Define a new limit for search user time line
                    if tweet_date < limit_date:
                        break
                    else:
                        if len(current_time_line) > 0:
                            max_id = current_time_line[len(current_time_line) - 1].id - 1

            dic_users_used_term[user] = tweets

        return dic_users_used_term

    def get_user_base(self, user_id, collect_from):
        # Get user base according type of analysis
        user_base = None
        if collect_from == "friends":
            user_base = self.api.GetFriendIDs(user_id=user_id)
        elif collect_from == "followers":
            user_base = self.api.GetFollowerIDs(user_id=user_id)

        # Get posts no more than 100 people
        if len(user_base) > 100:
            user_base = random.sample(user_base, 100)

        return user_base

    def get_bot_mentions(self, search_limit):
        mentions_collection = []
        max_id = 9000000000000000000
        since_id = int(search_limit)

        while True:
            try:
                # Get the most recent mentions for the authenticating user
                mentions = self.api.GetMentions(since_id=since_id, max_id=max_id, count=200)
            except error.TwitterError as e:
                message = str(datetime.now()) + " - " + "GetMentions" + ": " + e.message[1] + "\n"
                file_utility.append('resources/errors_log.txt', message)
                continue

            # Print user and text of mentions collected
            for mention in mentions:
                mentions_collection.append(mention)

            if len(mentions) == 0:
                break
            else:
                max_id = mentions_collection[len(mentions) - 1].id - 1

        # Update value from since_id
        if len(mentions_collection) > 0:
            file_utility.write('resources/search_limit.txt', mentions_collection[0].id)
            print(str(len(mentions_collection)) + " menções coletadas. Limite de consulta atualizado")
        else:
            print("Não há novas menções")

        # Return mentions collected
        return mentions_collection

    def get_user_name(self, user_id):
        try:
            user = self.api.GetUser(user_id=user_id)
            return user.screen_name
        except error.TwitterError as e:
            message = str(datetime.now()) + " - " + "GetUser" + ": " + e.message[1] + "\n"
            file_utility.append('resources/errors_log.txt', message)

    # TODO-Eric modify algorithm to use this method
    def get_users_timeline(self, users):
        max_id = 9000000000000000000
        user_dict = {}

        for user in users:
            time.sleep(1)

            try:
                current_time_line = self.api.GetUserTimeline(count=200, user_id=user, max_id=max_id,
                                                             exclude_replies=False, include_rts=True)
                user_dict[user] = current_time_line
            except error.TwitterError as e:
                message = str(datetime.now()) + " - " + "GetUserTimeline" + ": " + e.message[1] + "\n"
                file_utility.append('resources/errors_log.txt', message)

        return user_dict


who_knows_bot = TwitterBot()
who_knows_bot.listener()
